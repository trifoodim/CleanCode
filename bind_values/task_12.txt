==1============================================================================
column = 0
exponent = 0
while column < size:
    for j in range(0, size - column):
        ...
        if is_lin_indep_columns:
            ...
            column += 1
        else:
            ...
    exponent += 1
----------------------------------------
Это фрагмент алгоритма построения локальной нормальной формы Смита для квадратной матрицы многочленов.
Данная версия алгоритма всегда начинает работу с крайнего левого столбца матрицы,
поэтому начальное значение переменной column - это не параметр, а часть алгоритма.
Это значение может поменяться только при изменении алгоритма,
или если в Python элементы списков вдруг начнут нумероваться в единицы.

Значение exponent = 0 - тоже часть алгоритма.
Сначала мы вычислим все столбцы с нулевой степенью множителя, по которому раскладываем матрицу,
потом - с первой степенью, и т.д.

Начальные значения переменных column и exponent связываются с ними на этапе написания кода.


==2============================================================================
int imgFlags = IMG_INIT_JPG;
if (IMG_Init(imgFlags) != imgFlags) {
    std::cout << "Failed to init SDL image" << std::endl;
    return -1;
}
atexit(IMG_Quit);
----------------------------------------
Значение переменной imgFlags связывается с ней на этапе компиляции.
Конкретные значения флагов в библиотеке SDL нам знать не нужно.

==3=============================================================================
argParser = argparse.ArgumentParser()
argParser.add_argument("inner", type=float)
argParser.add_argument("outer", type=int)
...
args = argParser.parse_args()
...
inner = args.inner
outer = args.outer
----------------------------------------
Значения переменных inner и outer (названных в соответствии с их математическими обозначениями)
могут измениться при каждом запуске программы.
Более того, несколько копий программы с разными значениями этих переменных
могут выполняться параллельно.

Значения переменных inner и outer связываются с ними на этапе выполнения кода.